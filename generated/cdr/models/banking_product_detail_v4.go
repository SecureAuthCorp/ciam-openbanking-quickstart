// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BankingProductDetailV4 BankingProductDetailV4
//
// swagger:model BankingProductDetailV4
type BankingProductDetailV4 struct {

	// additional information
	AdditionalInformation *BankingProductAdditionalInformationV2 `json:"additionalInformation,omitempty"`

	// A link to an application web page where this product can be applied for.
	ApplicationURI string `json:"applicationUri,omitempty"`

	// A label of the brand for the product. Able to be used for filtering. For data holders with single brands this value is still required
	// Required: true
	Brand *string `json:"brand"`

	// An optional display name of the brand
	BrandName string `json:"brandName,omitempty"`

	// An array of bundles that this product participates in.  Each bundle is described by free form information but also by a list of product IDs of the other products that are included in the bundle.  It is assumed that the current product is included in the bundle also
	Bundles []*BankingProductBundle `json:"bundles"`

	// An array of card art images
	CardArt []*CardArt `json:"cardArt"`

	// Constraints on the application for or operation of the product such as minimum balances or limit thresholds
	Constraints []*BankingProductConstraint `json:"constraints"`

	// Interest rates available for deposits
	DepositRates []*BankingProductDepositRate `json:"depositRates"`

	// A description of the product
	// Required: true
	Description *string `json:"description"`

	// The date and time from which this product is effective (ie. is available for origination).  Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom string `json:"effectiveFrom,omitempty"`

	// The date and time at which this product will be retired and will no longer be offered.  Used to enable the managed deprecation of products
	EffectiveTo string `json:"effectiveTo,omitempty"`

	// Eligibility criteria for the product
	Eligibility []*BankingProductEligibility `json:"eligibility"`

	// Array of features available for the product
	Features []*BankingProductFeatureV2 `json:"features"`

	// Fees applicable for the product
	Fees []*BankingProductFee `json:"fees"`

	// Indicates whether the product is specifically tailored to a circumstance.  In this case fees and prices are significantly negotiated depending on context. While all products are open to a degree of tailoring this flag indicates that tailoring is expected and thus that the provision of specific fees and rates is not applicable
	// Required: true
	IsTailored *bool `json:"isTailored"`

	// The last date and time that the information for this product was changed (or the creation date for the product if it has never been altered)
	// Required: true
	LastUpdated *string `json:"lastUpdated"`

	// Interest rates charged against lending balances
	LendingRates []*BankingProductLendingRateV2 `json:"lendingRates"`

	// The display name of the product
	// Required: true
	Name *string `json:"name"`

	// product category
	// Required: true
	ProductCategory *BankingProductCategory `json:"productCategory"`

	// A data holder specific unique identifier for this product. This identifier must be unique to a product but does not otherwise need to adhere to ID permanence guidelines.
	// Required: true
	ProductID *string `json:"productId"`
}

// Validate validates this banking product detail v4
func (m *BankingProductDetailV4) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdditionalInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBrand(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBundles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardArt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConstraints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepositRates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEligibility(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFees(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsTailored(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLendingRates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductDetailV4) validateAdditionalInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.AdditionalInformation) { // not required
		return nil
	}

	if m.AdditionalInformation != nil {
		if err := m.AdditionalInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("additionalInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("additionalInformation")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductDetailV4) validateBrand(formats strfmt.Registry) error {

	if err := validate.Required("brand", "body", m.Brand); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductDetailV4) validateBundles(formats strfmt.Registry) error {
	if swag.IsZero(m.Bundles) { // not required
		return nil
	}

	for i := 0; i < len(m.Bundles); i++ {
		if swag.IsZero(m.Bundles[i]) { // not required
			continue
		}

		if m.Bundles[i] != nil {
			if err := m.Bundles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bundles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bundles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) validateCardArt(formats strfmt.Registry) error {
	if swag.IsZero(m.CardArt) { // not required
		return nil
	}

	for i := 0; i < len(m.CardArt); i++ {
		if swag.IsZero(m.CardArt[i]) { // not required
			continue
		}

		if m.CardArt[i] != nil {
			if err := m.CardArt[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cardArt" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cardArt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) validateConstraints(formats strfmt.Registry) error {
	if swag.IsZero(m.Constraints) { // not required
		return nil
	}

	for i := 0; i < len(m.Constraints); i++ {
		if swag.IsZero(m.Constraints[i]) { // not required
			continue
		}

		if m.Constraints[i] != nil {
			if err := m.Constraints[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("constraints" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("constraints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) validateDepositRates(formats strfmt.Registry) error {
	if swag.IsZero(m.DepositRates) { // not required
		return nil
	}

	for i := 0; i < len(m.DepositRates); i++ {
		if swag.IsZero(m.DepositRates[i]) { // not required
			continue
		}

		if m.DepositRates[i] != nil {
			if err := m.DepositRates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("depositRates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("depositRates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductDetailV4) validateEligibility(formats strfmt.Registry) error {
	if swag.IsZero(m.Eligibility) { // not required
		return nil
	}

	for i := 0; i < len(m.Eligibility); i++ {
		if swag.IsZero(m.Eligibility[i]) { // not required
			continue
		}

		if m.Eligibility[i] != nil {
			if err := m.Eligibility[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("eligibility" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("eligibility" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) validateFeatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Features) { // not required
		return nil
	}

	for i := 0; i < len(m.Features); i++ {
		if swag.IsZero(m.Features[i]) { // not required
			continue
		}

		if m.Features[i] != nil {
			if err := m.Features[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("features" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) validateFees(formats strfmt.Registry) error {
	if swag.IsZero(m.Fees) { // not required
		return nil
	}

	for i := 0; i < len(m.Fees); i++ {
		if swag.IsZero(m.Fees[i]) { // not required
			continue
		}

		if m.Fees[i] != nil {
			if err := m.Fees[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fees" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fees" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) validateIsTailored(formats strfmt.Registry) error {

	if err := validate.Required("isTailored", "body", m.IsTailored); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductDetailV4) validateLastUpdated(formats strfmt.Registry) error {

	if err := validate.Required("lastUpdated", "body", m.LastUpdated); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductDetailV4) validateLendingRates(formats strfmt.Registry) error {
	if swag.IsZero(m.LendingRates) { // not required
		return nil
	}

	for i := 0; i < len(m.LendingRates); i++ {
		if swag.IsZero(m.LendingRates[i]) { // not required
			continue
		}

		if m.LendingRates[i] != nil {
			if err := m.LendingRates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lendingRates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lendingRates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductDetailV4) validateProductCategory(formats strfmt.Registry) error {

	if err := validate.Required("productCategory", "body", m.ProductCategory); err != nil {
		return err
	}

	if err := validate.Required("productCategory", "body", m.ProductCategory); err != nil {
		return err
	}

	if m.ProductCategory != nil {
		if err := m.ProductCategory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productCategory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("productCategory")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductDetailV4) validateProductID(formats strfmt.Registry) error {

	if err := validate.Required("productId", "body", m.ProductID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this banking product detail v4 based on the context it is used
func (m *BankingProductDetailV4) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdditionalInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBundles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCardArt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConstraints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepositRates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEligibility(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFees(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLendingRates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProductCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductDetailV4) contextValidateAdditionalInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.AdditionalInformation != nil {
		if err := m.AdditionalInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("additionalInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("additionalInformation")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateBundles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Bundles); i++ {

		if m.Bundles[i] != nil {
			if err := m.Bundles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bundles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bundles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateCardArt(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CardArt); i++ {

		if m.CardArt[i] != nil {
			if err := m.CardArt[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cardArt" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cardArt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateConstraints(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Constraints); i++ {

		if m.Constraints[i] != nil {
			if err := m.Constraints[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("constraints" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("constraints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateDepositRates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DepositRates); i++ {

		if m.DepositRates[i] != nil {
			if err := m.DepositRates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("depositRates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("depositRates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateEligibility(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Eligibility); i++ {

		if m.Eligibility[i] != nil {
			if err := m.Eligibility[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("eligibility" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("eligibility" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateFeatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Features); i++ {

		if m.Features[i] != nil {
			if err := m.Features[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("features" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateFees(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Fees); i++ {

		if m.Fees[i] != nil {
			if err := m.Fees[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fees" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fees" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateLendingRates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LendingRates); i++ {

		if m.LendingRates[i] != nil {
			if err := m.LendingRates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lendingRates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lendingRates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductDetailV4) contextValidateProductCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.ProductCategory != nil {
		if err := m.ProductCategory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productCategory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("productCategory")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BankingProductDetailV4) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BankingProductDetailV4) UnmarshalBinary(b []byte) error {
	var res BankingProductDetailV4
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
