// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BankingProductDepositRate BankingProductDepositRate
//
// swagger:model BankingProductDepositRate
type BankingProductDepositRate struct {

	// Display text providing more information on the rate
	AdditionalInfo string `json:"additionalInfo,omitempty"`

	// Link to a web page with more information on this rate
	AdditionalInfoURI string `json:"additionalInfoUri,omitempty"`

	// Generic field containing additional information relevant to the [depositRateType](#tocSproductdepositratetypedoc) specified. Whether mandatory or not is dependent on the value of [depositRateType](#tocSproductdepositratetypedoc)
	AdditionalValue string `json:"additionalValue,omitempty"`

	// The period after which the calculated amount(s) (see calculationFrequency) are 'applied' (i.e. debited or credited) to the account. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	ApplicationFrequency string `json:"applicationFrequency,omitempty"`

	// The period after which the rate is applied to the balance to calculate the amount due for the period. Calculation of the amount is often daily (as balances may change) but accumulated until the total amount is 'applied' to the account (see applicationFrequency). Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	CalculationFrequency string `json:"calculationFrequency,omitempty"`

	// deposit rate type
	// Required: true
	DepositRateType *DepositRateType `json:"depositRateType"`

	// The rate to be applied
	// Required: true
	Rate *string `json:"rate"`

	// Rate tiers applicable for this rate
	Tiers []*BankingProductRateTierV3 `json:"tiers"`
}

// Validate validates this banking product deposit rate
func (m *BankingProductDepositRate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepositRateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductDepositRate) validateDepositRateType(formats strfmt.Registry) error {

	if err := validate.Required("depositRateType", "body", m.DepositRateType); err != nil {
		return err
	}

	if err := validate.Required("depositRateType", "body", m.DepositRateType); err != nil {
		return err
	}

	if m.DepositRateType != nil {
		if err := m.DepositRateType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("depositRateType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("depositRateType")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductDepositRate) validateRate(formats strfmt.Registry) error {

	if err := validate.Required("rate", "body", m.Rate); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductDepositRate) validateTiers(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiers) { // not required
		return nil
	}

	for i := 0; i < len(m.Tiers); i++ {
		if swag.IsZero(m.Tiers[i]) { // not required
			continue
		}

		if m.Tiers[i] != nil {
			if err := m.Tiers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tiers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tiers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this banking product deposit rate based on the context it is used
func (m *BankingProductDepositRate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepositRateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductDepositRate) contextValidateDepositRateType(ctx context.Context, formats strfmt.Registry) error {

	if m.DepositRateType != nil {
		if err := m.DepositRateType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("depositRateType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("depositRateType")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductDepositRate) contextValidateTiers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tiers); i++ {

		if m.Tiers[i] != nil {
			if err := m.Tiers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tiers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tiers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *BankingProductDepositRate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BankingProductDepositRate) UnmarshalBinary(b []byte) error {
	var res BankingProductDepositRate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
