// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BankingProductDiscount BankingProductDiscount
//
// swagger:model BankingProductDiscount
type BankingProductDiscount struct {

	// A discount rate calculated based on a proportion of the calculated interest accrued on the account. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
	AccruedRate string `json:"accruedRate,omitempty"`

	// Display text providing more information on the discount
	AdditionalInfo string `json:"additionalInfo,omitempty"`

	// Link to a web page with more information on this discount
	AdditionalInfoURI string `json:"additionalInfoUri,omitempty"`

	// Generic field containing additional information relevant to the [discountType](#tocSproductdiscounttypedoc) specified. Whether mandatory or not is dependent on the value of [discountType](#tocSproductdiscounttypedoc)
	AdditionalValue string `json:"additionalValue,omitempty"`

	// Dollar value of the discount. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory.
	Amount string `json:"amount,omitempty"`

	// A discount rate calculated based on a proportion of the balance. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
	BalanceRate string `json:"balanceRate,omitempty"`

	// Description of the discount
	// Required: true
	Description *string `json:"description"`

	// discount type
	// Required: true
	DiscountType *DiscountType `json:"discountType"`

	// Eligibility constraints that apply to this discount. Mandatory if ``discountType`` is ``ELIGIBILITY_ONLY``.
	Eligibility []*BankingProductDiscountEligibility `json:"eligibility"`

	// A discount rate calculated based on a proportion of the fee to which this discount is attached. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
	FeeRate string `json:"feeRate,omitempty"`

	// A discount rate calculated based on a proportion of a transaction. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory
	TransactionRate string `json:"transactionRate,omitempty"`
}

// Validate validates this banking product discount
func (m *BankingProductDiscount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiscountType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEligibility(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductDiscount) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductDiscount) validateDiscountType(formats strfmt.Registry) error {

	if err := validate.Required("discountType", "body", m.DiscountType); err != nil {
		return err
	}

	if err := validate.Required("discountType", "body", m.DiscountType); err != nil {
		return err
	}

	if m.DiscountType != nil {
		if err := m.DiscountType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("discountType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("discountType")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductDiscount) validateEligibility(formats strfmt.Registry) error {
	if swag.IsZero(m.Eligibility) { // not required
		return nil
	}

	for i := 0; i < len(m.Eligibility); i++ {
		if swag.IsZero(m.Eligibility[i]) { // not required
			continue
		}

		if m.Eligibility[i] != nil {
			if err := m.Eligibility[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("eligibility" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("eligibility" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this banking product discount based on the context it is used
func (m *BankingProductDiscount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDiscountType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEligibility(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductDiscount) contextValidateDiscountType(ctx context.Context, formats strfmt.Registry) error {

	if m.DiscountType != nil {
		if err := m.DiscountType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("discountType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("discountType")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductDiscount) contextValidateEligibility(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Eligibility); i++ {

		if m.Eligibility[i] != nil {
			if err := m.Eligibility[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("eligibility" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("eligibility" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *BankingProductDiscount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BankingProductDiscount) UnmarshalBinary(b []byte) error {
	var res BankingProductDiscount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
