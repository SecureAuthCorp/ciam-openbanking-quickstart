// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AccountBalancesData AccountBalancesData
//
// Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
//
// swagger:model AccountBalancesData
type AccountBalancesData struct {

	// Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática Expresso em valor monetário com 4 casas decimais.
	// Example: 100000.04
	// Required: true
	AutomaticallyInvestedAmount *float64 `json:"automaticallyInvestedAmount"`

	// Moeda referente ao valor do saldo disponível com aplicação automática, segundo modelo ISO-4217. p.ex. 'BRL'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
	// Example: BRL
	// Required: true
	// Max Length: 3
	// Pattern: ^(\w{3}){1}$
	AutomaticallyInvestedAmountCurrency *string `json:"automaticallyInvestedAmountCurrency"`

	// Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Admite saldo negativo. Expresso em valor monetário com 4 casas decimais.
	// Example: 100000.04
	// Required: true
	AvailableAmount *float64 `json:"availableAmount"`

	// Moeda referente ao valor do saldo disponível, segundo modelo ISO-4217. p.ex. 'BRL'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
	// Example: BRL
	// Required: true
	// Max Length: 3
	// Pattern: ^(\w{3}){1}$
	AvailableAmountCurrency *string `json:"availableAmountCurrency"`

	// Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos Expresso em valor monetário com 4 casas decimais.
	// Example: 99.9999
	// Required: true
	BlockedAmount *float64 `json:"blockedAmount"`

	// Moeda referente ao valor do saldo bloqueado, segundo modelo ISO-4217. p.ex. 'BRL'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
	// Example: BRL
	// Required: true
	// Max Length: 3
	// Pattern: ^(\w{3}){1}$
	BlockedAmountCurrency *string `json:"blockedAmountCurrency"`
}

// Validate validates this account balances data
func (m *AccountBalancesData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAutomaticallyInvestedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutomaticallyInvestedAmountCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableAmountCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockedAmountCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountBalancesData) validateAutomaticallyInvestedAmount(formats strfmt.Registry) error {

	if err := validate.Required("automaticallyInvestedAmount", "body", m.AutomaticallyInvestedAmount); err != nil {
		return err
	}

	return nil
}

func (m *AccountBalancesData) validateAutomaticallyInvestedAmountCurrency(formats strfmt.Registry) error {

	if err := validate.Required("automaticallyInvestedAmountCurrency", "body", m.AutomaticallyInvestedAmountCurrency); err != nil {
		return err
	}

	if err := validate.MaxLength("automaticallyInvestedAmountCurrency", "body", *m.AutomaticallyInvestedAmountCurrency, 3); err != nil {
		return err
	}

	if err := validate.Pattern("automaticallyInvestedAmountCurrency", "body", *m.AutomaticallyInvestedAmountCurrency, `^(\w{3}){1}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountBalancesData) validateAvailableAmount(formats strfmt.Registry) error {

	if err := validate.Required("availableAmount", "body", m.AvailableAmount); err != nil {
		return err
	}

	return nil
}

func (m *AccountBalancesData) validateAvailableAmountCurrency(formats strfmt.Registry) error {

	if err := validate.Required("availableAmountCurrency", "body", m.AvailableAmountCurrency); err != nil {
		return err
	}

	if err := validate.MaxLength("availableAmountCurrency", "body", *m.AvailableAmountCurrency, 3); err != nil {
		return err
	}

	if err := validate.Pattern("availableAmountCurrency", "body", *m.AvailableAmountCurrency, `^(\w{3}){1}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountBalancesData) validateBlockedAmount(formats strfmt.Registry) error {

	if err := validate.Required("blockedAmount", "body", m.BlockedAmount); err != nil {
		return err
	}

	return nil
}

func (m *AccountBalancesData) validateBlockedAmountCurrency(formats strfmt.Registry) error {

	if err := validate.Required("blockedAmountCurrency", "body", m.BlockedAmountCurrency); err != nil {
		return err
	}

	if err := validate.MaxLength("blockedAmountCurrency", "body", *m.BlockedAmountCurrency, 3); err != nil {
		return err
	}

	if err := validate.Pattern("blockedAmountCurrency", "body", *m.BlockedAmountCurrency, `^(\w{3}){1}$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this account balances data based on context it is used
func (m *AccountBalancesData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AccountBalancesData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountBalancesData) UnmarshalBinary(b []byte) error {
	var res AccountBalancesData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
