// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AccountIdentificationData AccountIdentificationData
//
// Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
//
// swagger:model AccountIdentificationData
type AccountIdentificationData struct {

	// Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	// Example: 6272
	// Required: true
	// Max Length: 4
	// Pattern: \d{4}|^NA$
	BranchCode *string `json:"branchCode"`

	// Dígito da conta
	// Example: 4
	// Required: true
	// Max Length: 1
	// Pattern: [\w\W\s]*
	CheckDigit *string `json:"checkDigit"`

	// Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas). O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe). O campo tem a anotação “n/a” (“não se aplica”) para os participantes do STR aos quais não é atribuído um número-código
	// Example: 1
	// Required: true
	// Max Length: 3
	// Pattern: \d{3}|^NA$
	CompeCode *string `json:"compeCode"`

	// Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. 'BRL'
	// Todos os saldos informados estão representados com a moeda vigente do Brasil
	// Example: BRL
	// Required: true
	// Max Length: 3
	// Pattern: ^(\w{3}){1}$
	Currency *string `json:"currency"`

	// Número da conta
	// Example: 24550245
	// Required: true
	// Max Length: 20
	// Pattern: ^\d{8,20}$|^NA$
	Number *string `json:"number"`

	// subtype
	// Required: true
	Subtype *EnumAccountSubType `json:"subtype"`

	// type
	// Required: true
	Type *EnumAccountType `json:"type"`
}

// Validate validates this account identification data
func (m *AccountIdentificationData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBranchCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCheckDigit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubtype(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountIdentificationData) validateBranchCode(formats strfmt.Registry) error {

	if err := validate.Required("branchCode", "body", m.BranchCode); err != nil {
		return err
	}

	if err := validate.MaxLength("branchCode", "body", *m.BranchCode, 4); err != nil {
		return err
	}

	if err := validate.Pattern("branchCode", "body", *m.BranchCode, `\d{4}|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountIdentificationData) validateCheckDigit(formats strfmt.Registry) error {

	if err := validate.Required("checkDigit", "body", m.CheckDigit); err != nil {
		return err
	}

	if err := validate.MaxLength("checkDigit", "body", *m.CheckDigit, 1); err != nil {
		return err
	}

	if err := validate.Pattern("checkDigit", "body", *m.CheckDigit, `[\w\W\s]*`); err != nil {
		return err
	}

	return nil
}

func (m *AccountIdentificationData) validateCompeCode(formats strfmt.Registry) error {

	if err := validate.Required("compeCode", "body", m.CompeCode); err != nil {
		return err
	}

	if err := validate.MaxLength("compeCode", "body", *m.CompeCode, 3); err != nil {
		return err
	}

	if err := validate.Pattern("compeCode", "body", *m.CompeCode, `\d{3}|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountIdentificationData) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("currency", "body", m.Currency); err != nil {
		return err
	}

	if err := validate.MaxLength("currency", "body", *m.Currency, 3); err != nil {
		return err
	}

	if err := validate.Pattern("currency", "body", *m.Currency, `^(\w{3}){1}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountIdentificationData) validateNumber(formats strfmt.Registry) error {

	if err := validate.Required("number", "body", m.Number); err != nil {
		return err
	}

	if err := validate.MaxLength("number", "body", *m.Number, 20); err != nil {
		return err
	}

	if err := validate.Pattern("number", "body", *m.Number, `^\d{8,20}$|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountIdentificationData) validateSubtype(formats strfmt.Registry) error {

	if err := validate.Required("subtype", "body", m.Subtype); err != nil {
		return err
	}

	if err := validate.Required("subtype", "body", m.Subtype); err != nil {
		return err
	}

	if m.Subtype != nil {
		if err := m.Subtype.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subtype")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("subtype")
			}
			return err
		}
	}

	return nil
}

func (m *AccountIdentificationData) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this account identification data based on the context it is used
func (m *AccountIdentificationData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSubtype(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountIdentificationData) contextValidateSubtype(ctx context.Context, formats strfmt.Registry) error {

	if m.Subtype != nil {
		if err := m.Subtype.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subtype")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("subtype")
			}
			return err
		}
	}

	return nil
}

func (m *AccountIdentificationData) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountIdentificationData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountIdentificationData) UnmarshalBinary(b []byte) error {
	var res AccountIdentificationData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
