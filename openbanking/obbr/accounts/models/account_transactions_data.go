// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AccountTransactionsData AccountTransactionsData
//
// swagger:model AccountTransactionsData
type AccountTransactionsData struct {

	// Valor da transação. Expressa em valor monetário com 4 casas decimais.
	// Example: 500.54
	// Required: true
	Amount *float64 `json:"amount"`

	// completed authorised payment type
	// Required: true
	CompletedAuthorisedPaymentType *EnumCompletedAuthorisedPaymentIndicator `json:"completedAuthorisedPaymentType"`

	// credit debit type
	// Required: true
	CreditDebitType *EnumCreditDebitIndicator `json:"creditDebitType"`

	// Código da Agência detentora da conta da pessoa envolvida na transação. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	// Example: 6272
	// Required: true
	// Max Length: 4
	// Pattern: \d{4}|^NA$
	PartieBranchCode *string `json:"partieBranchCode"`

	// Dígito da conta da pessoa envolvida na transação
	// Example: 4
	// Required: true
	// Max Length: 1
	// Pattern: [\w\W\s]*
	PartieCheckDigit *string `json:"partieCheckDigit"`

	// Identificação da pessoa envolvida na transação: pagador ou recebedor (Preencher com o CPF ou CNPJ, sem formatação)
	// Example: 43908445778
	// Required: true
	// Max Length: 14
	// Pattern: ^\d{11}$|^\d{14}$|^NA$
	PartieCnpjCpf *string `json:"partieCnpjCpf"`

	// Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas) referente à pessoa envolvida na transação. O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe). O campo tem a anotação “n/a” (“não se aplica”) para os participantes do STR aos quais não é atribuído um número-código
	// Example: 1
	// Required: true
	// Max Length: 3
	// Pattern: \d{3}|^NA$
	PartieCompeCode *string `json:"partieCompeCode"`

	// Número da conta da pessoa envolvida na transação
	// Example: 67890854360
	// Required: true
	// Max Length: 20
	// Pattern: ^\d{8,20}$|^NA$
	PartieNumber *string `json:"partieNumber"`

	// partie person type
	// Required: true
	PartiePersonType *EnumPartiePersonType `json:"partiePersonType"`

	// Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. 'BRL'.
	// Example: BRL
	// Required: true
	// Max Length: 3
	// Pattern: ^(\w{3}){1}$
	TransactionCurrency *string `json:"transactionCurrency"`

	// Se indicador de transação:
	// TRANSACAO_EFETIVADA - corresponde a data de lançamento da transação
	// LANCAMENTO_FUTURO - corresponde a data prevista de efetivação da transação
	// Example: 2021-01-07
	// Required: true
	// Max Length: 10
	// Pattern: ^(\d{4})-(1[0-2]|0?[1-9])-(3[01]|[12][0-9]|0?[1-9])$
	TransactionDate *string `json:"transactionDate"`

	// Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
	// Example: TXpRMU9UQTROMWhZV2xSU1FUazJSMDl
	// Max Length: 100
	// Pattern: ^[a-zA-Z0-9][a-zA-Z0-9\-]{0,99}$
	TransactionID string `json:"transactionId,omitempty"`

	// Campo livre que corresponde ao identificador da transação na instituição financeira
	// Example: TRANSFCWAR5TXHCX5I9IDBHML8082N8NEO30M6LNNG7ANAYIJYRM00ZBZPU8
	// Required: true
	// Max Length: 60
	// Pattern: [\w\W\s]*
	TransactionName *string `json:"transactionName"`

	// type
	// Required: true
	Type *EnumTransactionTypes `json:"type"`
}

// Validate validates this account transactions data
func (m *AccountTransactionsData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompletedAuthorisedPaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreditDebitType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartieBranchCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartieCheckDigit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartieCnpjCpf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartieCompeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartieNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartiePersonType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountTransactionsData) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validateCompletedAuthorisedPaymentType(formats strfmt.Registry) error {

	if err := validate.Required("completedAuthorisedPaymentType", "body", m.CompletedAuthorisedPaymentType); err != nil {
		return err
	}

	if err := validate.Required("completedAuthorisedPaymentType", "body", m.CompletedAuthorisedPaymentType); err != nil {
		return err
	}

	if m.CompletedAuthorisedPaymentType != nil {
		if err := m.CompletedAuthorisedPaymentType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("completedAuthorisedPaymentType")
			}
			return err
		}
	}

	return nil
}

func (m *AccountTransactionsData) validateCreditDebitType(formats strfmt.Registry) error {

	if err := validate.Required("creditDebitType", "body", m.CreditDebitType); err != nil {
		return err
	}

	if err := validate.Required("creditDebitType", "body", m.CreditDebitType); err != nil {
		return err
	}

	if m.CreditDebitType != nil {
		if err := m.CreditDebitType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("creditDebitType")
			}
			return err
		}
	}

	return nil
}

func (m *AccountTransactionsData) validatePartieBranchCode(formats strfmt.Registry) error {

	if err := validate.Required("partieBranchCode", "body", m.PartieBranchCode); err != nil {
		return err
	}

	if err := validate.MaxLength("partieBranchCode", "body", *m.PartieBranchCode, 4); err != nil {
		return err
	}

	if err := validate.Pattern("partieBranchCode", "body", *m.PartieBranchCode, `\d{4}|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validatePartieCheckDigit(formats strfmt.Registry) error {

	if err := validate.Required("partieCheckDigit", "body", m.PartieCheckDigit); err != nil {
		return err
	}

	if err := validate.MaxLength("partieCheckDigit", "body", *m.PartieCheckDigit, 1); err != nil {
		return err
	}

	if err := validate.Pattern("partieCheckDigit", "body", *m.PartieCheckDigit, `[\w\W\s]*`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validatePartieCnpjCpf(formats strfmt.Registry) error {

	if err := validate.Required("partieCnpjCpf", "body", m.PartieCnpjCpf); err != nil {
		return err
	}

	if err := validate.MaxLength("partieCnpjCpf", "body", *m.PartieCnpjCpf, 14); err != nil {
		return err
	}

	if err := validate.Pattern("partieCnpjCpf", "body", *m.PartieCnpjCpf, `^\d{11}$|^\d{14}$|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validatePartieCompeCode(formats strfmt.Registry) error {

	if err := validate.Required("partieCompeCode", "body", m.PartieCompeCode); err != nil {
		return err
	}

	if err := validate.MaxLength("partieCompeCode", "body", *m.PartieCompeCode, 3); err != nil {
		return err
	}

	if err := validate.Pattern("partieCompeCode", "body", *m.PartieCompeCode, `\d{3}|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validatePartieNumber(formats strfmt.Registry) error {

	if err := validate.Required("partieNumber", "body", m.PartieNumber); err != nil {
		return err
	}

	if err := validate.MaxLength("partieNumber", "body", *m.PartieNumber, 20); err != nil {
		return err
	}

	if err := validate.Pattern("partieNumber", "body", *m.PartieNumber, `^\d{8,20}$|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validatePartiePersonType(formats strfmt.Registry) error {

	if err := validate.Required("partiePersonType", "body", m.PartiePersonType); err != nil {
		return err
	}

	if err := validate.Required("partiePersonType", "body", m.PartiePersonType); err != nil {
		return err
	}

	if m.PartiePersonType != nil {
		if err := m.PartiePersonType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partiePersonType")
			}
			return err
		}
	}

	return nil
}

func (m *AccountTransactionsData) validateTransactionCurrency(formats strfmt.Registry) error {

	if err := validate.Required("transactionCurrency", "body", m.TransactionCurrency); err != nil {
		return err
	}

	if err := validate.MaxLength("transactionCurrency", "body", *m.TransactionCurrency, 3); err != nil {
		return err
	}

	if err := validate.Pattern("transactionCurrency", "body", *m.TransactionCurrency, `^(\w{3}){1}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validateTransactionDate(formats strfmt.Registry) error {

	if err := validate.Required("transactionDate", "body", m.TransactionDate); err != nil {
		return err
	}

	if err := validate.MaxLength("transactionDate", "body", *m.TransactionDate, 10); err != nil {
		return err
	}

	if err := validate.Pattern("transactionDate", "body", *m.TransactionDate, `^(\d{4})-(1[0-2]|0?[1-9])-(3[01]|[12][0-9]|0?[1-9])$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(m.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("transactionId", "body", m.TransactionID, 100); err != nil {
		return err
	}

	if err := validate.Pattern("transactionId", "body", m.TransactionID, `^[a-zA-Z0-9][a-zA-Z0-9\-]{0,99}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validateTransactionName(formats strfmt.Registry) error {

	if err := validate.Required("transactionName", "body", m.TransactionName); err != nil {
		return err
	}

	if err := validate.MaxLength("transactionName", "body", *m.TransactionName, 60); err != nil {
		return err
	}

	if err := validate.Pattern("transactionName", "body", *m.TransactionName, `[\w\W\s]*`); err != nil {
		return err
	}

	return nil
}

func (m *AccountTransactionsData) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this account transactions data based on the context it is used
func (m *AccountTransactionsData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCompletedAuthorisedPaymentType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreditDebitType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartiePersonType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountTransactionsData) contextValidateCompletedAuthorisedPaymentType(ctx context.Context, formats strfmt.Registry) error {

	if m.CompletedAuthorisedPaymentType != nil {
		if err := m.CompletedAuthorisedPaymentType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("completedAuthorisedPaymentType")
			}
			return err
		}
	}

	return nil
}

func (m *AccountTransactionsData) contextValidateCreditDebitType(ctx context.Context, formats strfmt.Registry) error {

	if m.CreditDebitType != nil {
		if err := m.CreditDebitType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("creditDebitType")
			}
			return err
		}
	}

	return nil
}

func (m *AccountTransactionsData) contextValidatePartiePersonType(ctx context.Context, formats strfmt.Registry) error {

	if m.PartiePersonType != nil {
		if err := m.PartiePersonType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partiePersonType")
			}
			return err
		}
	}

	return nil
}

func (m *AccountTransactionsData) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountTransactionsData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountTransactionsData) UnmarshalBinary(b []byte) error {
	var res AccountTransactionsData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
