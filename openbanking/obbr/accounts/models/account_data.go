// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AccountData AccountData
//
// swagger:model AccountData
type AccountData struct {

	// Identifica de forma única  a conta do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
	// Example: 92792126019929279212650822221989319252576
	// Required: true
	// Max Length: 100
	// Pattern: ^[a-zA-Z0-9][a-zA-Z0-9\-]{0,99}$
	AccountID *string `json:"accountId"`

	// Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	// Example: 6272
	// Required: true
	// Max Length: 4
	// Pattern: \d{4}|^NA$
	BranchCode *string `json:"branchCode"`

	// Nome da Marca reportada pelo participante do Open Banking. O conceito a que se refere a 'marca' é em essência uma promessa da empresa em fornecer uma série específica de atributos, benefícios e serviços uniformes aos clientes.
	// Example: Organização A
	// Required: true
	// Max Length: 80
	// Pattern: [\w\W\s]*
	BrandName *string `json:"brandName"`

	// Dígito da conta
	// Example: 4
	// Required: true
	// Max Length: 1
	// Pattern: [\w\W\s]*
	CheckDigit *string `json:"checkDigit"`

	// Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
	// Example: 21128159000166
	// Required: true
	// Max Length: 14
	// Pattern: \d{14}|^NA$
	CompanyCnpj *string `json:"companyCnpj"`

	// Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	// Example: 1
	// Required: true
	// Max Length: 3
	// Pattern: \d{3}|^NA$
	CompeCode *string `json:"compeCode"`

	// Número da conta
	// Example: 94088392
	// Required: true
	// Max Length: 20
	// Pattern: ^\d{8,20}$|^NA$
	Number *string `json:"number"`

	// type
	// Required: true
	Type *EnumAccountType `json:"type"`
}

// Validate validates this account data
func (m *AccountData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBranchCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBrandName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCheckDigit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompanyCnpj(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountData) validateAccountID(formats strfmt.Registry) error {

	if err := validate.Required("accountId", "body", m.AccountID); err != nil {
		return err
	}

	if err := validate.MaxLength("accountId", "body", *m.AccountID, 100); err != nil {
		return err
	}

	if err := validate.Pattern("accountId", "body", *m.AccountID, `^[a-zA-Z0-9][a-zA-Z0-9\-]{0,99}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountData) validateBranchCode(formats strfmt.Registry) error {

	if err := validate.Required("branchCode", "body", m.BranchCode); err != nil {
		return err
	}

	if err := validate.MaxLength("branchCode", "body", *m.BranchCode, 4); err != nil {
		return err
	}

	if err := validate.Pattern("branchCode", "body", *m.BranchCode, `\d{4}|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountData) validateBrandName(formats strfmt.Registry) error {

	if err := validate.Required("brandName", "body", m.BrandName); err != nil {
		return err
	}

	if err := validate.MaxLength("brandName", "body", *m.BrandName, 80); err != nil {
		return err
	}

	if err := validate.Pattern("brandName", "body", *m.BrandName, `[\w\W\s]*`); err != nil {
		return err
	}

	return nil
}

func (m *AccountData) validateCheckDigit(formats strfmt.Registry) error {

	if err := validate.Required("checkDigit", "body", m.CheckDigit); err != nil {
		return err
	}

	if err := validate.MaxLength("checkDigit", "body", *m.CheckDigit, 1); err != nil {
		return err
	}

	if err := validate.Pattern("checkDigit", "body", *m.CheckDigit, `[\w\W\s]*`); err != nil {
		return err
	}

	return nil
}

func (m *AccountData) validateCompanyCnpj(formats strfmt.Registry) error {

	if err := validate.Required("companyCnpj", "body", m.CompanyCnpj); err != nil {
		return err
	}

	if err := validate.MaxLength("companyCnpj", "body", *m.CompanyCnpj, 14); err != nil {
		return err
	}

	if err := validate.Pattern("companyCnpj", "body", *m.CompanyCnpj, `\d{14}|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountData) validateCompeCode(formats strfmt.Registry) error {

	if err := validate.Required("compeCode", "body", m.CompeCode); err != nil {
		return err
	}

	if err := validate.MaxLength("compeCode", "body", *m.CompeCode, 3); err != nil {
		return err
	}

	if err := validate.Pattern("compeCode", "body", *m.CompeCode, `\d{3}|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountData) validateNumber(formats strfmt.Registry) error {

	if err := validate.Required("number", "body", m.Number); err != nil {
		return err
	}

	if err := validate.MaxLength("number", "body", *m.Number, 20); err != nil {
		return err
	}

	if err := validate.Pattern("number", "body", *m.Number, `^\d{8,20}$|^NA$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountData) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this account data based on the context it is used
func (m *AccountData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountData) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountData) UnmarshalBinary(b []byte) error {
	var res AccountData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
