// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BankingProductFee BankingProductFee
//
// swagger:model BankingProductFee
type BankingProductFee struct {

	// The indicative frequency with which the fee is calculated on the account. Only applies if balanceRate or accruedRate is also present. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	AccrualFrequency string `json:"accrualFrequency,omitempty"`

	// A fee rate calculated based on a proportion of the calculated interest accrued on the account. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* "VARIABLE" is supplied
	AccruedRate string `json:"accruedRate,omitempty"`

	// Display text providing more information on the fee
	AdditionalInfo string `json:"additionalInfo,omitempty"`

	// Link to a web page with more information on this fee
	AdditionalInfoURI string `json:"additionalInfoUri,omitempty"`

	// Generic field containing additional information relevant to the [feeType](#tocSproductfeetypedoc) specified. Whether mandatory or not is dependent on the value of [feeType](#tocSproductfeetypedoc)
	AdditionalValue string `json:"additionalValue,omitempty"`

	// The amount charged for the fee. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* "VARIABLE" is supplied
	Amount string `json:"amount,omitempty"`

	// A fee rate calculated based on a proportion of the balance. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* "VARIABLE" is supplied.
	BalanceRate string `json:"balanceRate,omitempty"`

	// The currency the fee will be charged in. Assumes AUD if absent
	Currency string `json:"currency,omitempty"`

	// An optional list of discounts to this fee that may be available
	Discounts []*BankingProductDiscount `json:"discounts"`

	// fee type
	// Required: true
	FeeType *FeeType `json:"feeType"`

	// Name of the fee
	// Required: true
	Name *string `json:"name"`

	// A fee rate calculated based on a proportion of a transaction. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* "VARIABLE" is supplied
	TransactionRate string `json:"transactionRate,omitempty"`
}

// Validate validates this banking product fee
func (m *BankingProductFee) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDiscounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductFee) validateDiscounts(formats strfmt.Registry) error {
	if swag.IsZero(m.Discounts) { // not required
		return nil
	}

	for i := 0; i < len(m.Discounts); i++ {
		if swag.IsZero(m.Discounts[i]) { // not required
			continue
		}

		if m.Discounts[i] != nil {
			if err := m.Discounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("discounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductFee) validateFeeType(formats strfmt.Registry) error {

	if err := validate.Required("feeType", "body", m.FeeType); err != nil {
		return err
	}

	if err := validate.Required("feeType", "body", m.FeeType); err != nil {
		return err
	}

	if m.FeeType != nil {
		if err := m.FeeType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feeType")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductFee) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this banking product fee based on the context it is used
func (m *BankingProductFee) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDiscounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeeType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductFee) contextValidateDiscounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Discounts); i++ {

		if m.Discounts[i] != nil {
			if err := m.Discounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("discounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductFee) contextValidateFeeType(ctx context.Context, formats strfmt.Registry) error {

	if m.FeeType != nil {
		if err := m.FeeType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feeType")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BankingProductFee) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BankingProductFee) UnmarshalBinary(b []byte) error {
	var res BankingProductFee
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
