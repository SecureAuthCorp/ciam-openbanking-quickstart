// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BankingBalance BankingBalance
//
// swagger:model BankingBalance
type BankingBalance struct {

	// A unique ID of the account adhering to the standards for ID permanence
	// Required: true
	AccountID *string `json:"accountId"`

	// Object representing the available limit amortised according to payment schedule. Assumed to be zero if absent
	AmortisedLimit string `json:"amortisedLimit,omitempty"`

	// Balance representing the amount of funds available for transfer. Assumed to be zero or positive
	// Required: true
	AvailableBalance *string `json:"availableBalance"`

	// Object representing the maximum amount of credit that is available for this account. Assumed to be zero if absent
	CreditLimit string `json:"creditLimit,omitempty"`

	// The currency for the balance amounts. If absent assumed to be AUD
	Currency string `json:"currency,omitempty"`

	// The balance of the account at this time. Should align to the balance available via other channels such as Internet Banking. Assumed to be negative if the customer has money owing
	// Required: true
	CurrentBalance *string `json:"currentBalance"`

	// Optional array of balances for the account in other currencies. Included to support accounts that support multi-currency purses such as Travel Cards
	Purses []*BankingBalancePurse `json:"purses"`
}

// Validate validates this banking balance
func (m *BankingBalance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePurses(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingBalance) validateAccountID(formats strfmt.Registry) error {

	if err := validate.Required("accountId", "body", m.AccountID); err != nil {
		return err
	}

	return nil
}

func (m *BankingBalance) validateAvailableBalance(formats strfmt.Registry) error {

	if err := validate.Required("availableBalance", "body", m.AvailableBalance); err != nil {
		return err
	}

	return nil
}

func (m *BankingBalance) validateCurrentBalance(formats strfmt.Registry) error {

	if err := validate.Required("currentBalance", "body", m.CurrentBalance); err != nil {
		return err
	}

	return nil
}

func (m *BankingBalance) validatePurses(formats strfmt.Registry) error {
	if swag.IsZero(m.Purses) { // not required
		return nil
	}

	for i := 0; i < len(m.Purses); i++ {
		if swag.IsZero(m.Purses[i]) { // not required
			continue
		}

		if m.Purses[i] != nil {
			if err := m.Purses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("purses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this banking balance based on the context it is used
func (m *BankingBalance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePurses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingBalance) contextValidatePurses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Purses); i++ {

		if m.Purses[i] != nil {
			if err := m.Purses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("purses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *BankingBalance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BankingBalance) UnmarshalBinary(b []byte) error {
	var res BankingBalance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
