// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BankingTransactionDetail BankingTransactionDetail
//
// swagger:model BankingTransactionDetail
type BankingTransactionDetail struct {

	// ID of the account for which transactions are provided
	// Required: true
	AccountID *string `json:"accountId"`

	// The value of the transaction. Negative values mean money was outgoing from the account
	// Required: true
	Amount *string `json:"amount"`

	// 6 Digit APCA number for the initiating institution. The field is fixed-width and padded with leading zeros if applicable.
	ApcaNumber string `json:"apcaNumber,omitempty"`

	// BPAY Biller Code for the transaction (if available)
	BillerCode string `json:"billerCode,omitempty"`

	// Name of the BPAY biller for the transaction (if available)
	BillerName string `json:"billerName,omitempty"`

	// BPAY CRN for the transaction (if available).<br/>Where the CRN contains sensitive information, it should be masked in line with how the Data Holder currently displays account identifiers in their existing online banking channels. If the contents of the CRN match the format of a Credit Card PAN they should be masked according to the rules applicable for MaskedPANString. If the contents are are otherwise sensitive, then it should be masked using the rules applicable for the MaskedAccountString common type.
	Crn string `json:"crn,omitempty"`

	// The currency for the transaction amount. AUD assumed if not present
	Currency string `json:"currency,omitempty"`

	// The transaction description as applied by the financial institution
	// Required: true
	Description *string `json:"description"`

	// The time the transaction was executed by the originating customer, if available
	ExecutionDateTime string `json:"executionDateTime,omitempty"`

	// extended data
	// Required: true
	ExtendedData *ExtendedData `json:"extendedData"`

	// True if extended information is available using the transaction detail end point. False if extended data is not available
	// Required: true
	IsDetailAvailable *bool `json:"isDetailAvailable"`

	// The merchant category code (or MCC) for an outgoing payment to a merchant
	MerchantCategoryCode string `json:"merchantCategoryCode,omitempty"`

	// Name of the merchant for an outgoing payment to a merchant
	MerchantName string `json:"merchantName,omitempty"`

	// The time the transaction was posted. This field is Mandatory if the transaction has status POSTED.  This is the time that appears on a standard statement
	PostingDateTime string `json:"postingDateTime,omitempty"`

	// The reference for the transaction provided by the originating institution. Empty string if no data provided
	// Required: true
	Reference *string `json:"reference"`

	// status
	// Required: true
	Status *Status `json:"status"`

	// A unique ID of the transaction adhering to the standards for ID permanence.  This is mandatory (through hashing if necessary) unless there are specific and justifiable technical reasons why a transaction cannot be uniquely identified for a particular account type. It is mandatory if `isDetailAvailable` is set to true.
	TransactionID string `json:"transactionId,omitempty"`

	// type
	// Required: true
	Type *Type `json:"type"`

	// Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry
	ValueDateTime string `json:"valueDateTime,omitempty"`
}

// Validate validates this banking transaction detail
func (m *BankingTransactionDetail) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtendedData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDetailAvailable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingTransactionDetail) validateAccountID(formats strfmt.Registry) error {

	if err := validate.Required("accountId", "body", m.AccountID); err != nil {
		return err
	}

	return nil
}

func (m *BankingTransactionDetail) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

func (m *BankingTransactionDetail) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *BankingTransactionDetail) validateExtendedData(formats strfmt.Registry) error {

	if err := validate.Required("extendedData", "body", m.ExtendedData); err != nil {
		return err
	}

	if m.ExtendedData != nil {
		if err := m.ExtendedData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("extendedData")
			}
			return err
		}
	}

	return nil
}

func (m *BankingTransactionDetail) validateIsDetailAvailable(formats strfmt.Registry) error {

	if err := validate.Required("isDetailAvailable", "body", m.IsDetailAvailable); err != nil {
		return err
	}

	return nil
}

func (m *BankingTransactionDetail) validateReference(formats strfmt.Registry) error {

	if err := validate.Required("reference", "body", m.Reference); err != nil {
		return err
	}

	return nil
}

func (m *BankingTransactionDetail) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *BankingTransactionDetail) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this banking transaction detail based on the context it is used
func (m *BankingTransactionDetail) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExtendedData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingTransactionDetail) contextValidateExtendedData(ctx context.Context, formats strfmt.Registry) error {

	if m.ExtendedData != nil {
		if err := m.ExtendedData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("extendedData")
			}
			return err
		}
	}

	return nil
}

func (m *BankingTransactionDetail) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *BankingTransactionDetail) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BankingTransactionDetail) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BankingTransactionDetail) UnmarshalBinary(b []byte) error {
	var res BankingTransactionDetail
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
