// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BankingProductV4 BankingProductV4
//
// swagger:model BankingProductV4
type BankingProductV4 struct {

	// additional information
	AdditionalInformation *BankingProductAdditionalInformationV2 `json:"additionalInformation,omitempty"`

	// A link to an application web page where this product can be applied for.
	ApplicationURI string `json:"applicationUri,omitempty"`

	// A label of the brand for the product. Able to be used for filtering. For data holders with single brands this value is still required
	// Required: true
	Brand *string `json:"brand"`

	// An optional display name of the brand
	BrandName string `json:"brandName,omitempty"`

	// An array of card art images
	CardArt []*CardArt `json:"cardArt"`

	// A description of the product
	// Required: true
	Description *string `json:"description"`

	// The date and time from which this product is effective (ie. is available for origination).  Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom string `json:"effectiveFrom,omitempty"`

	// The date and time at which this product will be retired and will no longer be offered.  Used to enable the managed deprecation of products
	EffectiveTo string `json:"effectiveTo,omitempty"`

	// Indicates whether the product is specifically tailored to a circumstance.  In this case fees and prices are significantly negotiated depending on context. While all products are open to a degree of tailoring this flag indicates that tailoring is expected and thus that the provision of specific fees and rates is not applicable
	// Required: true
	IsTailored *bool `json:"isTailored"`

	// The last date and time that the information for this product was changed (or the creation date for the product if it has never been altered)
	// Required: true
	LastUpdated *string `json:"lastUpdated"`

	// The display name of the product
	// Required: true
	Name *string `json:"name"`

	// product category
	// Required: true
	ProductCategory *BankingProductCategory `json:"productCategory"`

	// A data holder specific unique identifier for this product. This identifier must be unique to a product but does not otherwise need to adhere to ID permanence guidelines.
	// Required: true
	ProductID *string `json:"productId"`
}

// Validate validates this banking product v4
func (m *BankingProductV4) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdditionalInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBrand(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardArt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsTailored(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductV4) validateAdditionalInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.AdditionalInformation) { // not required
		return nil
	}

	if m.AdditionalInformation != nil {
		if err := m.AdditionalInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("additionalInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("additionalInformation")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductV4) validateBrand(formats strfmt.Registry) error {

	if err := validate.Required("brand", "body", m.Brand); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductV4) validateCardArt(formats strfmt.Registry) error {
	if swag.IsZero(m.CardArt) { // not required
		return nil
	}

	for i := 0; i < len(m.CardArt); i++ {
		if swag.IsZero(m.CardArt[i]) { // not required
			continue
		}

		if m.CardArt[i] != nil {
			if err := m.CardArt[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cardArt" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cardArt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductV4) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductV4) validateIsTailored(formats strfmt.Registry) error {

	if err := validate.Required("isTailored", "body", m.IsTailored); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductV4) validateLastUpdated(formats strfmt.Registry) error {

	if err := validate.Required("lastUpdated", "body", m.LastUpdated); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductV4) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *BankingProductV4) validateProductCategory(formats strfmt.Registry) error {

	if err := validate.Required("productCategory", "body", m.ProductCategory); err != nil {
		return err
	}

	if err := validate.Required("productCategory", "body", m.ProductCategory); err != nil {
		return err
	}

	if m.ProductCategory != nil {
		if err := m.ProductCategory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productCategory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("productCategory")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductV4) validateProductID(formats strfmt.Registry) error {

	if err := validate.Required("productId", "body", m.ProductID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this banking product v4 based on the context it is used
func (m *BankingProductV4) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdditionalInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCardArt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProductCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BankingProductV4) contextValidateAdditionalInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.AdditionalInformation != nil {
		if err := m.AdditionalInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("additionalInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("additionalInformation")
			}
			return err
		}
	}

	return nil
}

func (m *BankingProductV4) contextValidateCardArt(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CardArt); i++ {

		if m.CardArt[i] != nil {
			if err := m.CardArt[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cardArt" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cardArt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BankingProductV4) contextValidateProductCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.ProductCategory != nil {
		if err := m.ProductCategory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productCategory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("productCategory")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BankingProductV4) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BankingProductV4) UnmarshalBinary(b []byte) error {
	var res BankingProductV4
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
