// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Holdingentity Holdingentity
//
// A holding in an investment account
//
// swagger:model Holdingentity
type Holdingentity struct {

	// Percent breakdown by asset class
	AssetClasses []*Portionentity `json:"assetClasses"`

	// Cost is average of all purchases for holding
	AverageCost bool `json:"averageCost,omitempty"`

	// If true, indicates that this holding is used to maintain proceeds from sales, dividends, and other cash postings to the investment account
	CashAccount bool `json:"cashAccount,omitempty"`

	// Change in current price compared to previous day's close
	ChangeInPrice float64 `json:"changeInPrice,omitempty"`

	// currency
	Currency *Currencyentity1 `json:"currency,omitempty"`

	// Current unit price
	CurrentUnitPrice float64 `json:"currentUnitPrice,omitempty"`

	// Current unit price as of date
	// Example: 2021-07-15T00:00:00.000Z
	// Format: date
	CurrentUnitPriceDate strfmt.Date `json:"currentUnitPriceDate,omitempty"`

	// debt security
	DebtSecurity *DebtSecurityentity2 `json:"debtSecurity,omitempty"`

	// The description of the holding
	Description string `json:"description,omitempty"`

	// Specify units to full precision with unlimited digits after decimal point
	DigitalUnits string `json:"digitalUnits,omitempty"`

	// For CDs, bonds, and other time-based holdings
	// Example: 2021-07-15T00:00:00.000Z
	// Format: date
	ExpirationDate strfmt.Date `json:"expirationDate,omitempty"`

	// Required for bonds. Face value at the time of data retrieved
	FaceValue float64 `json:"faceValue,omitempty"`

	// Percent breakdown by FI-specific asset class percentage breakdown
	FiAssetClasses []*FIPortionentity `json:"fiAssetClasses"`

	// Array of FI-specific attributes
	FiAttributes []*FIAttributeentity `json:"fiAttributes"`

	// held in account
	HeldInAccount HeldInAccount2 `json:"heldInAccount,omitempty"`

	// Long term persistent identity of the holding
	// Max Length: 256
	HoldingID string `json:"holdingId,omitempty"`

	// Holding name or security name
	HoldingName string `json:"holdingName,omitempty"`

	// holding sub type
	HoldingSubType HoldingSubType2 `json:"holdingSubType,omitempty"`

	// holding type
	HoldingType HoldingType2 `json:"holdingType,omitempty"`

	// inv401k source
	Inv401kSource Investment401kSourceType4 `json:"inv401kSource,omitempty"`

	// Market value at the time of data retrieved
	MarketValue float64 `json:"marketValue,omitempty"`

	// mutual fund security
	MutualFundSecurity *MutualFundSecurityentity2 `json:"mutualFundSecurity,omitempty"`

	// option security
	OptionSecurity *OptionSecurityentity2 `json:"optionSecurity,omitempty"`

	// Date of original purchase
	// Example: 2021-07-15T00:00:00.000Z
	// Format: date
	OriginalPurchaseDate strfmt.Date `json:"originalPurchaseDate,omitempty"`

	// other security
	OtherSecurity *OtherSecurityentity2 `json:"otherSecurity,omitempty"`

	// position type
	PositionType PositionType1 `json:"positionType,omitempty"`

	// Price of holding at the time of purchase
	PurchasedPrice float64 `json:"purchasedPrice,omitempty"`

	// For CDs, bonds, and other rate based holdings
	Rate float64 `json:"rate,omitempty"`

	// Unique identifier of security
	SecurityID string `json:"securityId,omitempty"`

	// security Id type
	SecurityIDType SecurityIDType1 `json:"securityIdType,omitempty"`

	// stock security
	StockSecurity *StockSecurityentity `json:"stockSecurity,omitempty"`

	// sweep security
	SweepSecurity *SweepSecurityentity `json:"sweepSecurity,omitempty"`

	// Ticker / Market symbol
	Symbol string `json:"symbol,omitempty"`

	// Breakdown by tax lot
	TaxLots []*TaxLotentity `json:"taxLots"`

	// Required for stock, mutual funds. Number of shares (with decimals)
	Units float64 `json:"units,omitempty"`
}

// Validate validates this holdingentity
func (m *Holdingentity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssetClasses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentUnitPriceDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFiAssetClasses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFiAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeldInAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHoldingID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHoldingSubType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHoldingType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInv401kSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMutualFundSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalPurchaseDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOtherSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePositionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityIDType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStockSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSweepSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxLots(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Holdingentity) validateAssetClasses(formats strfmt.Registry) error {
	if swag.IsZero(m.AssetClasses) { // not required
		return nil
	}

	for i := 0; i < len(m.AssetClasses); i++ {
		if swag.IsZero(m.AssetClasses[i]) { // not required
			continue
		}

		if m.AssetClasses[i] != nil {
			if err := m.AssetClasses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("assetClasses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("assetClasses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Holdingentity) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("currency")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) validateCurrentUnitPriceDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrentUnitPriceDate) { // not required
		return nil
	}

	if err := validate.FormatOf("currentUnitPriceDate", "body", "date", m.CurrentUnitPriceDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Holdingentity) validateDebtSecurity(formats strfmt.Registry) error {
	if swag.IsZero(m.DebtSecurity) { // not required
		return nil
	}

	if m.DebtSecurity != nil {
		if err := m.DebtSecurity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("debtSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("debtSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) validateExpirationDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpirationDate) { // not required
		return nil
	}

	if err := validate.FormatOf("expirationDate", "body", "date", m.ExpirationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Holdingentity) validateFiAssetClasses(formats strfmt.Registry) error {
	if swag.IsZero(m.FiAssetClasses) { // not required
		return nil
	}

	for i := 0; i < len(m.FiAssetClasses); i++ {
		if swag.IsZero(m.FiAssetClasses[i]) { // not required
			continue
		}

		if m.FiAssetClasses[i] != nil {
			if err := m.FiAssetClasses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fiAssetClasses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fiAssetClasses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Holdingentity) validateFiAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.FiAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.FiAttributes); i++ {
		if swag.IsZero(m.FiAttributes[i]) { // not required
			continue
		}

		if m.FiAttributes[i] != nil {
			if err := m.FiAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fiAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fiAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Holdingentity) validateHeldInAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.HeldInAccount) { // not required
		return nil
	}

	if err := m.HeldInAccount.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("heldInAccount")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("heldInAccount")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) validateHoldingID(formats strfmt.Registry) error {
	if swag.IsZero(m.HoldingID) { // not required
		return nil
	}

	if err := validate.MaxLength("holdingId", "body", m.HoldingID, 256); err != nil {
		return err
	}

	return nil
}

func (m *Holdingentity) validateHoldingSubType(formats strfmt.Registry) error {
	if swag.IsZero(m.HoldingSubType) { // not required
		return nil
	}

	if err := m.HoldingSubType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("holdingSubType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("holdingSubType")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) validateHoldingType(formats strfmt.Registry) error {
	if swag.IsZero(m.HoldingType) { // not required
		return nil
	}

	if err := m.HoldingType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("holdingType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("holdingType")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) validateInv401kSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Inv401kSource) { // not required
		return nil
	}

	if err := m.Inv401kSource.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("inv401kSource")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("inv401kSource")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) validateMutualFundSecurity(formats strfmt.Registry) error {
	if swag.IsZero(m.MutualFundSecurity) { // not required
		return nil
	}

	if m.MutualFundSecurity != nil {
		if err := m.MutualFundSecurity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mutualFundSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mutualFundSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) validateOptionSecurity(formats strfmt.Registry) error {
	if swag.IsZero(m.OptionSecurity) { // not required
		return nil
	}

	if m.OptionSecurity != nil {
		if err := m.OptionSecurity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("optionSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("optionSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) validateOriginalPurchaseDate(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginalPurchaseDate) { // not required
		return nil
	}

	if err := validate.FormatOf("originalPurchaseDate", "body", "date", m.OriginalPurchaseDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Holdingentity) validateOtherSecurity(formats strfmt.Registry) error {
	if swag.IsZero(m.OtherSecurity) { // not required
		return nil
	}

	if m.OtherSecurity != nil {
		if err := m.OtherSecurity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("otherSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("otherSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) validatePositionType(formats strfmt.Registry) error {
	if swag.IsZero(m.PositionType) { // not required
		return nil
	}

	if err := m.PositionType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("positionType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("positionType")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) validateSecurityIDType(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityIDType) { // not required
		return nil
	}

	if err := m.SecurityIDType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("securityIdType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("securityIdType")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) validateStockSecurity(formats strfmt.Registry) error {
	if swag.IsZero(m.StockSecurity) { // not required
		return nil
	}

	if m.StockSecurity != nil {
		if err := m.StockSecurity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stockSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stockSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) validateSweepSecurity(formats strfmt.Registry) error {
	if swag.IsZero(m.SweepSecurity) { // not required
		return nil
	}

	if m.SweepSecurity != nil {
		if err := m.SweepSecurity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sweepSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sweepSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) validateTaxLots(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxLots) { // not required
		return nil
	}

	for i := 0; i < len(m.TaxLots); i++ {
		if swag.IsZero(m.TaxLots[i]) { // not required
			continue
		}

		if m.TaxLots[i] != nil {
			if err := m.TaxLots[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxLots" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxLots" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this holdingentity based on the context it is used
func (m *Holdingentity) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAssetClasses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDebtSecurity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFiAssetClasses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFiAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeldInAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHoldingSubType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHoldingType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInv401kSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMutualFundSecurity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOptionSecurity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOtherSecurity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePositionType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecurityIDType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStockSecurity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSweepSecurity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxLots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Holdingentity) contextValidateAssetClasses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AssetClasses); i++ {

		if m.AssetClasses[i] != nil {
			if err := m.AssetClasses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("assetClasses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("assetClasses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Holdingentity) contextValidateCurrency(ctx context.Context, formats strfmt.Registry) error {

	if m.Currency != nil {
		if err := m.Currency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("currency")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) contextValidateDebtSecurity(ctx context.Context, formats strfmt.Registry) error {

	if m.DebtSecurity != nil {
		if err := m.DebtSecurity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("debtSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("debtSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) contextValidateFiAssetClasses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FiAssetClasses); i++ {

		if m.FiAssetClasses[i] != nil {
			if err := m.FiAssetClasses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fiAssetClasses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fiAssetClasses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Holdingentity) contextValidateFiAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FiAttributes); i++ {

		if m.FiAttributes[i] != nil {
			if err := m.FiAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fiAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fiAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Holdingentity) contextValidateHeldInAccount(ctx context.Context, formats strfmt.Registry) error {

	if err := m.HeldInAccount.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("heldInAccount")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("heldInAccount")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) contextValidateHoldingSubType(ctx context.Context, formats strfmt.Registry) error {

	if err := m.HoldingSubType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("holdingSubType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("holdingSubType")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) contextValidateHoldingType(ctx context.Context, formats strfmt.Registry) error {

	if err := m.HoldingType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("holdingType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("holdingType")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) contextValidateInv401kSource(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Inv401kSource.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("inv401kSource")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("inv401kSource")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) contextValidateMutualFundSecurity(ctx context.Context, formats strfmt.Registry) error {

	if m.MutualFundSecurity != nil {
		if err := m.MutualFundSecurity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mutualFundSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mutualFundSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) contextValidateOptionSecurity(ctx context.Context, formats strfmt.Registry) error {

	if m.OptionSecurity != nil {
		if err := m.OptionSecurity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("optionSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("optionSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) contextValidateOtherSecurity(ctx context.Context, formats strfmt.Registry) error {

	if m.OtherSecurity != nil {
		if err := m.OtherSecurity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("otherSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("otherSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) contextValidatePositionType(ctx context.Context, formats strfmt.Registry) error {

	if err := m.PositionType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("positionType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("positionType")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) contextValidateSecurityIDType(ctx context.Context, formats strfmt.Registry) error {

	if err := m.SecurityIDType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("securityIdType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("securityIdType")
		}
		return err
	}

	return nil
}

func (m *Holdingentity) contextValidateStockSecurity(ctx context.Context, formats strfmt.Registry) error {

	if m.StockSecurity != nil {
		if err := m.StockSecurity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stockSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stockSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) contextValidateSweepSecurity(ctx context.Context, formats strfmt.Registry) error {

	if m.SweepSecurity != nil {
		if err := m.SweepSecurity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sweepSecurity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sweepSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *Holdingentity) contextValidateTaxLots(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaxLots); i++ {

		if m.TaxLots[i] != nil {
			if err := m.TaxLots[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxLots" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxLots" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Holdingentity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Holdingentity) UnmarshalBinary(b []byte) error {
	var res Holdingentity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
